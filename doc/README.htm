<html>
<head><title>README.htm for the Wayang project</title></head>
<body>
<h1>README.htm for the Wayang project</h1>

<h2>Contents</h2>
<ul>
 <li><a href="#about">About</a></li>
 <li><a href="#design">System design</a></li>
 <li><a href="#setup">How to setup</a></li>
 <li><a href="#running">How to run</a></li>
 <li><a href="#output">What you should expect to see</a></li>
 <li><a href="#viz">The Visualizer</a></li>
 <li><a href="#testcases">How to create test cases</a></li>
 <li><a href="#logging">Logging</a></li>
 <li><a href="#restrictions">Requirements for input SWFs</a></li>
 <li><a href="#troubleshooting">Troubleshooting</a></li>
 <li><a href="#notes">Notes</a></li>
</ul>

<h2><a name="about">About</a></h2>
The Wayang project is an attempt to create a computational cognitive model of how people 
spontaneously attribute actions, intentions, and other mental states (or purely physical causes) to simple 2D objects
based largely on their movement.

<p>"Wayang" is an Indonesian word for theatre, specifically "shadow" and "imagination"
[<a href="http://en.wikipedia.org/wiki/Wayang">Wikipedia</a>].</p>

<h2><a name="design">System design</a></h2>
<p>The diagram below illustrates the major system parts of the Wayang codebase and its information flows.</p>
<img src="http://wooden-robot.net/images/WayangSystemDesign20100311.png"/>

<h2><a name="setup">How to setup</a></h2>
The following steps will allow you to start the Wayang visualization and run high-level units tests from it.
The steps also describe how to run all the low-level automated tests (which display a green or red
indicator in the IDE of whether the tests passed or not).
<ol>
<li>As of 20 May 2011, ECLiPSe CLP is 32-bit only. This means you will have to use the 32-bit JDK, even if you are on 64-bit Windows, and probably
the 32-bit Eclipse IDE as well. The current JDK is 1.6 Update 25, and its installer will not set PATH for you on Windows 7 64-bit. Also, to ensure the IDE
will use the right JVM (if another is ever installed), I added the following to eclipse.ini:
<pre>
-vm
C:\Program Files (x86)\Java\jdk1.6.0_25\bin\javaw.exe
</pre>If you install 64-bit IDE and try to run it with 32-bit Java, you will get an error like this: <code>Failed to load jni shared library "Program Files (x86)\Java\jdk1.6.0_20\jre\bin\client\jvm.dll"</code></li>
<li>You should already have these in place:
 <ul>
  <li>Installed the Eclipse IDE (for EE Developers) [<a href="http://cogsys.ihpc.a-star.edu.sg/ccss-main-folder/systems-support/software-development-tools/prolog-java-svn-eclipse-ide-setup">How-to on CSC wiki</a>]</li>
  <li>Installed support for SVN in the IDE, probably using Subclipse</li>
  <li>Installed the <a href="http://eclipse-clp.org">ECLiPSe constraint logic programming framework</a>. (Note that the Eclipse IDE and ECLiPSe are entirely different applications.)
   <ol>
    <li>When prompted for the working directory, I suggest <code>Dropbox\Projects\EclipseWorkspace\Wayang\test\ECLiPSe</code></li>
	<li>You might also want to go to Program Files | Eclipse 6.0 | TkEclipse, pin it to your taskbar, and once in the taskbar, edit its Properties | Start In to be the directory above.</li>
	<li>We use .pro to indicate pure Prolog files and reserve .ecl for source that uses CLP-specific features; by default, CLP uses .pl for Prolog (which others normally use for Perl). To allow TkEclipse's file dialogs to show our .pro files by default, edit <code>C:\Program Files\ECLiPSe 6.0\lib_tcl\eclipse_tools.tcl</code> around line 200 to match these:
	<pre>{{ECLiPSe Files} {.ecl .pro}}</pre>
	<pre>{{Prolog Files} {.pro}}</pre>
	</li>
   </ol>
  </li>
  <li>Checked-out this project, Wayang, into the IDE</li>
  <li>Installed support for the TestNG Java testing framework in the IDE.
    <ul>
     <li>You install it as a "Software Update" to the IDE, just like the way you added Subclipse support. When you
      go to Help | Software Updates | Available Software, use url <code>http://beust.com/eclipse</code> instead of
      the Subclipse url.</li>
    </ul>
  </li> 
 </ul>
</li>
<li>Go to the Project menu and select Build Automatically, so the application is rebuilt every time you save one of its
files.</li>

<li>(The following steps are adapted from <a href="http://wooden-robot.net/2010/01/03/how-to-enable-testng-launch-configurations-in-eclipse-ide-windows/">a more general how-to I wrote for setting up TestNG</a>.)</li>
<li>Make sure you haven't hidden any launch configuration types
<ol>
	<li>Go to the top menu bar and select Window | Preferences.</li>
	<li>In the left pane, select Run/Debug | Launching | Launch Configurations. On the right side, make sure that Java Application and TestNG are shown and not checked. (You may have to check 'Filter checked launch types' temporarily in order to scroll or uncheck some items.)</li>
</ol>
</li>
<li>Create a launch configuration for "low-level" Java only tests. These tests don't depend on ECLiPSe CLP. (The IDE doesn't save launch
 configurations to a file, AFAIK, so I can't checkin one for you; each person has to recreate mine.)
<ol>
	<li><img src="http://wooden-robot.net/images/ideRunConfigsTurnkey.png"/>Go to the top menu bar and click the down-facing black triangle to the right of the Run button (a green circle with a white triangle in it). This should trigger a dropdown menu that includes "Run Configurations..." Select it.</li>
	<li>Select TestNG in the left pane, then click the New button in the upper left (the white rectangle with a yellow plus in the upper right).</li>
	<li>Enter name "Wayang_LowLevel_JavaOnly" for the new launch config</li>
	<li>Under the Test tab,
	 <ol>
	  <li>Use the Browse button for the Project field and select Wayang</li>
	  <li>Select the Suite radio button and use the Browse button to select test/testng_LowLevel_JavaOnly.xml</li>
	 </ol>
	</li>
	<li>To save your edits, click Apply. When you're done editing, click Close (or you could execute the test by clicking Run).</li>
</ol>
</li>
<li>Create a launch configuration for "low-level" tests that depend on ECLiPSe CLP.
<ol>
	<li> Follow steps 1 and 2 in the procedure for creating a launch configuration for low-level Java only tests above.</li>
	<li> Enter name "Wayang_LowLevel_DependsOnCLP" for the new launch config </li>
	<li>Under the Test tab,
	 <ol>
	  <li>Use the Browse button for the Project field and select Wayang</li>
	  <li>Select the Suite radio button and use the Browse button to select test/testng_LowLevel_DependsOnCLP.xml</li>
	 </ol>
	</li>
	<li>Under the Arguments tab,
	 <ol>
	  <li><font color=red>IMPORTANT:</font> In the VM Arguments box, enter "-Declipse.directory="C:\Program Files\ECLiPSe 6.0" -Xms128M -Xmx256M".
	   (The latter part tells the IDE to
	    increase the amount of RAM allocated to this Java application.)</li>
	 </ol>
	</li>
	<li>To save your edits, click Apply. When you're done editing, click Close (or you could execute the test by clicking Run).</li>
</ol>
</li>
<li>Verify that the low-level tests were setup correctly
  <ol>
	<li>Run the Java only tests by selecting the black triangle again near the green Run button, and then selecting Wayang_LowLevel_JavaOnly</li>
	<li>The Console tab should show something like the following:
<hr/>
<pre>[Parser] Running:
  <em>pathToYourProject</em>\Wayang\test\testng_LowLevel.xml

...Wayang settings:                 Shapes fudge factor = 4
                                   Twips per spatial unit = 65.8
    Error to allow when comparing successive magnitudes = 0.1
                                            Graph width = 400
                                           Graph height = 200
                                  Graph node separation = 80
                                           Graph margin = 30
   Configured perceptual limits:
     minPerceptibleAreaChangePerMsec = 0.1
     minPerceptibleChangeInPosition = 2.0
     minAreaOverDistanceToAvoidFlicker = 4.0
     minPerceptibleArea = 4.0
     minPerceptibleRGBDifference = 8.0
     maxElapsedTimeToAvoidFlicker = 90.0
     minPerceptibleColorChangePerMsec = 0.5
...LocalPathToSWF = input/circle15mm_translation.swf
...Confirmed that file is SWF formatted.
...Properties in SWF header:         SWF version = 8
                                     frame count = 5
                                      frame rate = 24; so, msec between frames = 41.0
                                background width = 10999twips ~ 167 spatial units
                                          height = 7999twips ~ 122 spatial units
                                           color = RGB (255; 255; 255)
										   
<em>Output for various other test SWF files omitted.</em>

===============================================
Wayang_outputForLowLevelTests
Total tests run: 8, Failures: 0, Skips: 0
===============================================</pre>
<hr/>
	</li>
	<li>A similar, more graphical view of the summary report should be available under the TestNG tab.
	<img src="http://wooden-robot.net/images/testngPositive.png"/><br>This is the
	green/red indicator of success I mentioned above. If the indicator is red, click on one of the methods below
	it that have a failure indicator. The right pane should show a stacktrace for the error.</li>
	<li>Run the tests that depend on ECLiPSe CLP by selecting the black triangle again near the green Run button, and then selecting Wayang_LowLevel_DependsOnCLP.
		Output should be similar to Wayang_LowLevel_JavaOnly.</li>
</ol>
<li>Create a launch config for "high-level" tests
<ol>
	<li>Go to the top menu bar, open the Run button's dropdown menu, and select "Run Configurations..." again.</li>
	<li>Again, select Java Application in the left pane, then click the New button in the upper left.</li>
	<li>Enter name "Wayang_HighLevel" for the new launch config</li>
	<li>Under the Main tab,
	 <ol>
	  <li>Use the Browse button for the Project field and select Wayang</li>
	  <li>For Main class, enter sg.ihpc.wayangTest.Main. Leave the checkboxes unselected.</li>
	  <li>To save your edits, click Apply. When you're done editing, click Close.</li>
	 </ol>
	</li>
	<li>Under the Arguments tab,
	 <ol>
	  <li><font color=red>IMPORTANT:</font> In the VM Arguments box, enter "-Declipse.directory="C:\Program Files\ECLiPSe 6.0" -Xms128M -Xmx256M".
	   (The latter part tells the IDE to
	    increase the amount of RAM allocated to this Java application.)</li>
	  <li>You might not be able to run on Windows7 x64. For one thing, you probably have to change the path above to say "Program Files (x86)" instead of "Program Files". Second, you might still get this error: &quot;Exception in thread "clpThread" java.lang.RuntimeException: Unsupported platform: Windows 7/amd64&quot;
	 </ol>
	</li>
</ol>
</li>
<li>Verify that the high-level tests were setup correctly by using the Run button's dropdown menu again and
 selecting "Wayang_HighLevel"
</ol>

<h2><a name="running">How to run</a></h2>
The only way to run Wayang currently is by running either the high-level or low-level tests; we don't anticipate a
need to run it any other way, since we just want to ensure that the model works and automated tests seem the best
way to do that.


<h2><a name="output">What you should expect to see</a></h2>
The console shows the following when the high-level tests first start running:
<hr/>
<pre>
...Wayang settings:                 Shapes fudge factor = 4
                                   Twips per spatial unit = 65.8
    Error to allow when comparing successive magnitudes = 0.1
                                            Graph width = 400
                                           Graph height = 200
                                  Graph node separation = 80
                                           Graph margin = 30
                      Num different arc widths in graph = 6
   Configured perceptual limits:
     minPerceptibleAreaChangePerMsec = 0.1
     minPerceptibleChangeInPosition = 2.0
     minAreaOverDistanceToAvoidFlicker = 4.0
     minPerceptibleArea = 4.0
     minPerceptibleRGBDifference = 8.0
     maxElapsedTimeToAvoidFlicker = 90.0
     minPerceptibleColorChangePerMsec = 0.5
...Confirmed that file is SWF formatted.
...Properties in SWF header:         SWF version = 8
                                     frame count = 3
                                      frame rate = 24; so, msec between frames = 41.0
                                background width = 10999twips ~ 167 spatial units
                                          height = 7999twips ~ 122 spatial units
                                           color = RGB (255; 255; 255)
Loaded the ATOM project.


Asserted <rule(stationaryTrajectory_baseStep, <=(cause(figureHasTrajectory(FigureId, StationaryTrajectory, ElapsedTime1, ElapsedTime2, CF, originally(Shape1, Color1), []), [[timestamp(ElapsedTime1), figure(FigureId, Position1, Shape1, Color1)], [timestamp(ElapsedTime2), figure(FigureId, Position2, Shape2, Color2)]]), [1 : compute([Position1 = position(X1, Y1), Position2 = position(X2, Y2)]), 2 : compute(StationaryTrajectory = stationaryTrajectory(originalPosition(X1, Y1))), 3 : compute(figureIsStationary(FigureId, observ1(ElapsedTime1, Position1, Shape1, Color1), observ2(ElapsedTime2, Position2, Shape2, Color2), StationaryTrajectory)), 4 : compute(CF is 0.7)]))>


Asserted <rule(linearMovingTrajectory_baseStep, <=(cause(figureHasTrajectory(FigureId, LinearMovingTrajectory, ElapsedTime1, ElapsedTime2, CF, originally(Shape1, Color1), []), [[timestamp(ElapsedTime1), figure(FigureId, Position1, Shape1, Color1)], [timestamp(ElapsedTime2), figure(FigureId, Position2, Shape2, Color2)]]), [1 : compute([Position1 = position(X1, Y1), Position2 = position(X2, Y2)]), 2 : compute(LinearMovingTrajectory = linearMovingTrajectory(lastPosition(X2, Y2), magnitude(XMagn, YMagn))), 3 : compute(figureMovesLinearly(FigureId, observ1(ElapsedTime1, Position1, Shape1, Color1), observ2(ElapsedTime2, Position2, Shape2, Color2), LinearMovingTrajectory)), 4 : compute(CF is 0.65)]))>


Asserted <rule(trajectory_recursiveStep, <=(cause(figureHasTrajectory(FigureId, Trajectory2, ElapsedTime1, ElapsedTime3, CF3, originally(Shape1, Color1), DrawInstrs), [figureHasTrajectory(FigureId, Trajectory1, ElapsedTime1, ElapsedTime2, CF2, originally(Shape1, Color1), _DrawInstrs1), [timestamp(ElapsedTime3), figure(FigureId, Position3, Shape3, Color3)]]), [1 : compute(Position3 = position(X3, Y3)), 2 : compute((Trajectory1 = stationaryTrajectory(originalPosition(X2, Y2)), Trajectory2 = stationaryTrajectory(originalPosition(X3, Y3)), Constraint = figureIsStationary(FigureId, observ1(ElapsedTime2, position(X2, Y2), Shape1, Color1), observ2(ElapsedTime3, Position3, Shape3, Color3), Trajectory2), call(Constraint), genDrawInstructions(Constraint, DrawInstrs), ConfidenceGrowthFactor = 0.15) ; (Trajectory1 = linearMovingTrajectory(lastPosition(X2, Y2), magnitude(XMagn1, YMagn1)), Trajectory2 = linearMovingTrajectory(lastPosition(X3, Y3), magnitude(XMagn2, YMagn2)), Constraint = figureMovesLinearly(FigureId, observ1(ElapsedTime2, position(X2, Y2), Shape1, Color1), observ2(ElapsedTime3, Position3, Shape3, Color3), Trajectory2), call(Constraint), genDrawInstructions([Constraint|Trajectory1], DrawInstrs), magnitudesAreWithinErrorRange(XMagn1, XMagn2), magnitudesAreWithinErrorRange(YMagn1, YMagn2), ConfidenceGrowthFactor = 0.1)), 4 : compute(incrementConfidenceAsymptotically(CF2, ConfidenceGrowthFactor, CF3))]))>
Created new OutOfProcessEclipse inference engine
</pre>
<hr/>
<p>Note that ATOM is an
inference engine I wrote in early 2009 and then ported to ECLiPSe. It does inference for Wayang.)</p>

<p>Here's an overview of what the values mean above:
<ol>
<li><b>Shapes fudge factor</b> - How many spatial units the longer axis can be from the shorter axis when deciding
   if a shape is a square or rectangle (or circle versus oval).</li>
<li><b>Twips per spatial unit</b> - Distance measurements that are encoded in SWFs are in "twips" units, and the Adobe
   docs say that a twip is a "logical pixel" size rather than an actual pixel size, since actual pixel sizes
   depend on what resolution you've set your display to. We want to measure everything in spatial units so we can
   compare to what experimental participants see on a screen; we found conversion factor 56.7 on a forum page.</li>
<li><b>Error to allow when comparing successive magnitudes</b> - The amount of "wiggle room" to allow when comparing
   a speed+direction impetus vector from one pair of observations with a similar vector from another pair of
   observations -- to see if the figure is moving consistently. (The value is currently a guess, to be informed by experiment).</li>
<li><b>Perceptual limits</b> - When frame descriptions arrive at the Observer Model
   (the CLP side) they are checked to determine which (if any) of the figures in the frame are perceptible --
   a figure might be too small or too similar in color to the background; such figures are filtered out before
   the parser can "see" them.</li>
<li><b>SWF version</b> - Wayang depends on a 3rd party SWF parser, Jswiff, which only works with SWFs encoded in
   Flash version 8 and below. If you encounter weird Wayang behavior for a new SWF, be sure to check the version
   number displayed here.</li>
<li><b>frame rate</b> - A value set in the SWF file that tells Flash players how fast to play it; Wayang uses it
   to determine an "elapsed time (msec)" value to give to each description it creates of successive frames.</li>
<li><b>color</b> - The color of the background. RGB(255;255;255) is white. Although Wayang generates descriptions
   of the color of each figure and the background, it doesn't use such descriptions currently (e.g., it doesn't
   try to determine if a figure is invisible due to having the same color as the background, and then pretend
   it doesn't know about the figure).</li>
</ol>
</p>


<p>At the end of a successful run of the high-level tests, you <s>should</s> might see a section like this in the console,
<hr/><pre>
TERM IN: settings([minPerceptibleAreaChangePerMsec(0.1), minPerceptibleChangeInPosition(2.0), minPerceptibleArea(4.0), minAreaOverDistanceToAvoidFlicker(4.0), minPerceptibleRGBDifference(8.0), maxElapsedTimeToAvoidFlicker(90.0), minPerceptibleColorChangePerMsec(0.5), maxAllowableErrorInMagnitude(0.1)])
TERM IN: frame([timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(61, 35), circle(13), color(255, 0, 0))])
TERM OUT: edgeSummary("edge1", [], 1, 2, "list", "completed", "[[timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(61, 35), circle(13), color(255, 0, 0))], 1.0, [[timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(61, 35), circle(13), color(255, 0, 0))]], []]")
TERM OUT: edgeSummary("edge2", ["edge1"], 1, 1, "figureHasTrajectory", "incomplete", "[figureHasTrajectory(1, linearMovingTrajectory(lastPosition(X2, Y2), magnitude(XMagn, YMagn)), 0, ElapsedTime2, 0.65, originally(circle(13), color(0, 0, 255))), 0.65, [], [[timestamp(0), figure(1, position(100, 55), circle(13), color(0, 0, 255))], [timestamp(ElapsedTime2), figure(1, position(X2, Y2), Shape2, Color2)]]]")
</pre><hr/>
followed by a section like this:
<hr/><pre>
TERM OUT: edgeSummary("edge64", ["edge36", "edge20"], 2, 4, "figureHasTrajectory", "completed", "[figureHasTrajectory(3, linearMovingTrajectory(lastPosition(87, 52), magnitude(0.317073170731707, 0.195121951219512)), 41, 82, 0.65, originally(circle(13), color(255, 0, 0))), 0.65, [figureHasTrajectory(3, linearMovingTrajectory(lastPosition(87, 52), magnitude(0.317073170731707, 0.195121951219512)), 41, 82, 0.65, originally(circle(13), color(255, 0, 0))), [[timestamp(41), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(74, 44), circle(13), color(255, 0, 0))]], [[timestamp(82), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(87, 52), circle(13), color(255, 0, 0))]]], []]")
TERM OUT: edgeSummary("edge65", ["edge64"], 2, 2, "figureHasTrajectory", "incomplete", "[figureHasTrajectory(3, linearMovingTrajectory(lastPosition(X3, Y3), magnitude(XMagn2, YMagn2)), 41, ElapsedTime3, 0.866666666666667, originally(circle(13), color(255, 0, 0))), 0.866666666666667, [], [figureHasTrajectory(3, linearMovingTrajectory(lastPosition(87, 52), magnitude(0.317073170731707, 0.195121951219512)), 41, 82, 0.65, originally(circle(13), color(255, 0, 0))), [timestamp(ElapsedTime3), figure(3, position(X3, Y3), Shape3, Color3)]]]")
TERM OUT: edgeSummary("edge66", ["edge65", "edge64"], 2, 4, "figureHasTrajectory", "incomplete", "[figureHasTrajectory(3, linearMovingTrajectory(lastPosition(X3, Y3), magnitude(XMagn2, YMagn2)), 41, ElapsedTime3, 0.866666666666667, originally(circle(13), color(255, 0, 0))), 0.866666666666667, [figureHasTrajectory(3, linearMovingTrajectory(lastPosition(87, 52), magnitude(0.317073170731707, 0.195121951219512)), 41, 82, 0.65, originally(circle(13), color(255, 0, 0))), [[timestamp(41), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(74, 44), circle(13), color(255, 0, 0))]], [[timestamp(82), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(87, 52), circle(13), color(255, 0, 0))]]], [[timestamp(ElapsedTime3), figure(3, position(X3, Y3), Shape3, Color3)]]]")
TERM IN: stop
</pre><hr/>

<p>An &quot;edge&quot; is just a datastructure we use to store a partially-supported explanation. (The term 
&quot;edge&quot; comes from the chart parser we have adapted.)

<p>TO BE UPDATED:</p>
<font color=gray>
Here's what its parts mean:
<ul>
 <li><em>Incomplete/Completed</em> - Completed edges represent explanations that have been fully supported; these
 correspond to a branchpoint in a syntax tree where all the leafs/slots of that branchpoint have been filled in.
 Incomplete edges are explanations that are only partially supported so far.</li>
 <li><em>CF</em> - confidence factor, a real number in [0..1] where 1 represents total confidence, but some
    incomplete edges may still have just a variable such as CF2.</li>
 <li><em>Span</em> - the frames between which the explanation applies. For example, a span of 2 4 means
  that frames 2 and 3 support the explanation (and frame 4 hasn't been seen yet). A completed edge whose span
  goes from 1 to the last frame represents an explanation that covers the entire animation.</li>
 <li><em>Label</em> - The explanation or description that we have (partially) abduced. For example,
 <code>hasImpetus(5, [11, 12], 20, ..., 0.88)</code> means that figure 5 has an impetus of 11 in the X direction and
 12 in the Y direction at elapsed time 20msec with confidence factor .88.</li>
 <li><em>Scenes identified</em> - Conditions that the label depended on and which have been satisfied. (Note: There 
  should be no variables in these scene terms. Variables start with a capital letter.)</li>
 <li><em>Scenes expected</em> - Conditions that the label depends on and which have NOT yet been satisfied.
  The parser will look to support these by matching them to upcoming frames (or inferences drawn from frames).
  (Note: These terms will almost always include variables that represent figures, times, and other values that
   are expected.)</li>
 <li><font color=red>NEW:</font> <em>Filterings</em> - Descriptions in predicate calculus of any figure that might have been filtered out because
   it wouldn't have been perceptible.</li>
 <li><font color=red>NEW:</font> <em>Discontinuities</em> - Descriptions of any figure state, such as a big change in size or color, that
   prevented a continuity rule from firing. These are meant not just for informational purposes but also to act as
   triggers for discontinuity-spanning rules (to be introduced later).</li>
 <li><font color=red>NEW:</font> <em>Tips</em> - Descriptions of figure states that might indicate a bug in the
   knowledge base, or that might reflect desired behavior for an unusual test case.</li>
</ul>
</font>

<h2><a name="viz">The Visualizer</a></h2>
This screen capture shows, on the right, a visualization of the chart parser
 data structures after running the "Circle moves linearly between neighbors" high-level test.
 The space on the left is a place-holder for an SWF player that will show overlays
 of what Wayang infers.
<img src="http://wooden-robot.net/images/vizSample.png"/>

<p>The graph on the right can be interpreted this way:
 <ol>
  <li>Each node represents a frame; for example, node 1 represents the first frame</li>
  <li>Nodes and arcs are never moved nor altered. Each one represents a completed step of reasoning
    that later reasoning can use to build more inclusive hypotheses.</li>
  <li>All arcs point rightward (sometimes arrow heads are obscured by other arrow heads). Each arc represents
    one or more rules that are hypothesized to connect all the frames between the start and end nodes.
    For example, a <strong>solid</strong> arc from node 1 to node 3 represents <strong>completed</strong>
    rules that have satisfied all of their conditions by matching them to frames 1 through 3, while a 
    <strong>dotted</strong> arc from 1 to 3 would represent <strong>incomplete</strong> rules that have
    satisfied only some of their conditions and which will be looking at the next higher-numbered node
    to see if they can complete themselves.</li>
  <li>"Self-loop" arcs (i.e., those that start and end at the same node) are nothing special; they're
    just incomplete rules that have managed to match only their first condition.</li>
  <li>Notice that some arcs start at node 2 or later. One might think that there would be no point in
    creating a hypothesis that can't cover the whole span because it doesn't even cover the first node,
    but a chart parser actually looks for short arcs in order to build longer ones. For example, arcs
    from 1 to 3 and from 3 to 4 might be used to build a new arc from 1 to 4.</li>
  <li>Arcs of different colors use different concepts. Gray arcs represent just the starting description
    of each frame; these arcs are always complete/solid and always have just length 1. Green arcs
    represent the concept "figureHasImpetus".
    Because "figureHasImpetus" is currently our most high-level and thus most interesting kind of
    hypothesis, a solid green arc that spans all nodes represents the most "compelling" hypothesis
    one can hope for for any input animation. We will use other colors for the concepts of intention
    and physical causes.</li>
  </ol>
</p>
<p>Such graphs are just the start of a visualizer debugging tool we're building. See
   doc/VisualizerRequirements.txt for details.</p>

<h2><a name="testcases">How to create test cases</a></h2>
The following steps should be followed to create new test cases:
<ol>
 <li>Under <code>Wayang\test\ECLiPSe\</code>, create a file whose name begins with <code>test_</code>. This file should contain an ECLiPSe
     test predicate whose name should end with <code>_edgesAreCorrect</code> for consistent naming. The body of this predicate should consist
     of 2 predicate calls: <code>populateEdgeSummariesForVerification/1</code> followed by <code>processFrames/0</code>. 
     <code>populateEdgeSummariesForVerification/1</code> should be called with a term provided in the same file. The name of this term 
     should end with <code>_edgeSummaries</code>, again, for consistent naming. The term should have 1 argument, which is the list of
     all the expected edge summaries to compare against. Each edge summary is enclosed in an <code>edgeSummary</code> term. Below is
     an example layout of the file:
     <hr><pre>
     
circleTranslation_edgesAreCorrect :-
populateEdgeSummariesForVerification(circleTranslation_edgeSummaries),
	
processFrames.
	

% The canonical set of completed and incomplete edges for the "circle15mm_translation.swf" scenario.
%
circleTranslation_edgeSummaries(
[edgeSummary("edge1", [], 1, 2, "list", "completed", "[[timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(61, 35), circle(13), color(255, 0, 0))], 1.0, [[timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(61, 35), circle(13), color(255, 0, 0))]], []]")
,edgeSummary("edge2", ["edge1"], 1, 1, "figureHasTrajectory", "incomplete", "[figureHasTrajectory(1, linearMovingTrajectory(lastPosition(X2, Y2), magnitude(XMagn, YMagn)), 0, ElapsedTime2, 0.65, originally(circle(13), color(255, 0, 0))), 0.65, [], [[timestamp(0), figure(1, position(61, 35), circle(13), color(255, 0, 0))], [timestamp(ElapsedTime2), figure(1, position(X2, Y2), Shape2, Color2)]]]")
,edgeSummary("edge3", ["edge2", "edge1"], 1, 2, "figureHasTrajectory", "incomplete", "[figureHasTrajectory(1, linearMovingTrajectory(lastPosition(X2, Y2), magnitude(XMagn, YMagn)), 0, ElapsedTime2, 0.65, originally(circle(13), color(255, 0, 0))), 0.65, [[timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(61, 35), circle(13), color(255, 0, 0))]], [[timestamp(ElapsedTime2), figure(1, position(X2, Y2), Shape2, Color2)]]]")
,edgeSummary("edge4", ["edge1"], 1, 1, "figureHasTrajectory", "incomplete", "[figureHasTrajectory(1, stationaryTrajectory(originalPosition(61, 35)), 0, ElapsedTime2, 0.7, originally(circle(13), color(255, 0, 0))), 0.7, [], [[timestamp(0), figure(1, position(61, 35), circle(13), color(255, 0, 0))], [timestamp(ElapsedTime2), figure(1, position(X2, Y2), Shape2, Color2)]]]")
]).
    
     </pre><hr/> 
 </li>
 <li>The steps below explain how to generate the edge summaries in the list above:
  <ol>	 
 	 <li>Create the file whose name begins with <code>test_</code> as outlined above, but instead of providing the list of expected edge 
 	     summaries in the <code>_edgeSummaries</code> term, provide an empty list <code>[]</code>.
 	 </li>
 	 <li>In <code>Wayang\test\sg\ihpc\wayangTest\viz\VizTestsDropdown.java</code> class, there is a <code>VizTestsDropdownItem</code>
 	 	 vector called <code>_coTestItems</code>. This vector contains the dropdown items corresponding to the high-level tests that can be
 	 	 run in the visualizer. In the constructor of VizTestsDropdown class, add the new test case to the vector as the following example
 	 	 shows:
 	 	 <hr/><pre>
_coTestItems.add(
	new VizTestsDropdownItem(
			"Lone circle moves curvilinearly", //Label for the dropdown item
			"src/ECLiPSe/Observer/KnowledgeBase_curvedTrajectory.ecl", //knowledge base file that contains the relevant rules
			"input/circle15mm_curvedTrajectory.swf", //the input .swf file
			"test/ECLiPSe/test_circleCurvedTrajectory.pro", //the test file
			"circleCurvedTrajectory_edgesAreCorrect", //the test predicate in the test file that needs to be run  
			oViz ));
 	 	 </pre><hr/>	 	    
 	 </li>
 	 <li>Run the high level test using the visualizer. As previously described, at the end of the high level test, you might see an output
 	 	 such as the following:
 	 	 <hr/><pre>
TERM IN: settings([minPerceptibleAreaChangePerMsec(0.1), minPerceptibleChangeInPosition(2.0), minPerceptibleArea(4.0), minAreaOverDistanceToAvoidFlicker(4.0), minPerceptibleRGBDifference(8.0), maxElapsedTimeToAvoidFlicker(90.0), minPerceptibleColorChangePerMsec(0.5), maxAllowableErrorInMagnitude(0.1)])
TERM IN: frame([timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(61, 35), circle(13), color(255, 0, 0))])
TERM OUT: edgeSummary("edge1", [], 1, 2, "list", "completed", "[[timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(61, 35), circle(13), color(255, 0, 0))], 1.0, [[timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 55), circle(13), color(0, 0, 255)), figure(2, position(70, 19), circle(13), color(51, 255, 0)), figure(3, position(61, 35), circle(13), color(255, 0, 0))]], []]")
TERM OUT: edgeSummary("edge2", ["edge1"], 1, 1, "figureHasTrajectory", "incomplete", "[figureHasTrajectory(1, linearMovingTrajectory(lastPosition(X2, Y2), magnitude(XMagn, YMagn)), 0, ElapsedTime2, 0.65, originally(circle(13), color(0, 0, 255))), 0.65, [], [[timestamp(0), figure(1, position(100, 55), circle(13), color(0, 0, 255))], [timestamp(ElapsedTime2), figure(1, position(X2, Y2), Shape2, Color2)]]]")
		 </pre><hr/>
		 Each of the edge summaries provided as output terms should be collected and then examined for correctness. If the edge summaries
		 are deemed to be correct, they are ready to be collected and added into the expected edge summary list. This edge summary list should
		 replace the empty list.
 	 </li>
  </ol>
 </li>
 <li>It is also possible to run tests in a standalone mode, purely on the ECLiPSe CLP side. In the same folder which contains the <code>test_</code>
 	 files, there are corresponding files whose names begin with <code>standalone_</code>. Such files should follow the structure of the
 	 following example file:
 	 <hr/><pre>
:- compile('stubsAndUtilsForStandalone.pro', 
	'../../src/ECLiPSe/Observer/KnowledgeBase_curvedTrajectory.ecl'
   ).
   
:- resetStandalone.

:- assert( inputForDebugging([ settings([minPerceptibleAreaChangePerMsec(0.1), 
                                         minPerceptibleChangeInPosition(2.0), 
                                         minPerceptibleArea(4.0), 
                                         minAreaOverDistanceToAvoidFlicker(4.0), 
                                         minPerceptibleRGBDifference(8.0), 
                                         maxElapsedTimeToAvoidFlicker(90.0), 
                                         minPerceptibleColorChangePerMsec(0.5), 
                                         maxAllowableErrorInMagnitude(0.1), 
                                         maxAllowableErrorInDegrees(3.0)
                                        ])
                              ,frame([timestamp(0), ground(167, 122, color(255, 255, 255)), figure(1, position(84, 61), circle(13), color(51, 255, 0))])
                              ,frame([timestamp(41), ground(167, 122, color(255, 255, 255)), figure(1, position(88, 65), circle(13), color(51, 255, 0))])
                              ,frame([timestamp(82), ground(167, 122, color(255, 255, 255)), figure(1, position(94, 67), circle(13), color(51, 255, 0))])
                              ,frame([timestamp(123), ground(167, 122, color(255, 255, 255)), figure(1, position(100, 65), circle(13), color(51, 255, 0))])
                              ,frame([timestamp(164), ground(167, 122, color(255, 255, 255)), figure(1, position(105, 61), circle(13), color(51, 255, 0))])
                              ,endOfFrames
                             ])).

:- compile('test_circleCurvedTrajectory.pro').
 	 </pre><hr/>
 	 It is structured as follows:
 	 <ul>
 	  <li>The first part loads <code>'stubsAndUtilsForStandalone.pro'</code> which contains necessary predicates, as well as the 
 	  	  relevant knowledge base file.
 	  </li>
 	  <li>The <code>resetStandalone/1</code> predicate is called to do necessary steps prior to the test run.
 	  </li>
 	  <li><code>inputForDebugging/1</code> contains a list of inputs that include the relevant settings as well as frame items that
 	  	  replace inputs that would be passed if an actual high-level test were run from the visualizer. The inputs simulate actual
 	  	  inputs from a <code>.swf</code> file. These inputs should be retrieved from a corresponding high-level test
 	  	  output which are labeled <code>TERM IN</code> (see above).
 	  </li>
 	  <li>Lastly, the corresponding <code>test_</code> file is loaded.
 	  </li>
 	 </ul>
 	 The <code>standalone_</code> file should be run through TkEclipse. The relevant test predicate to call is the predicate in the
 	 <code>test_</code> file whose name ends with <code>_edgesAreCorrect</code>.
 </li>	 
</ol>

<h2><a name="restrictions">Requirements for input SWFs</a></h2>
<ul>
 <li>Neither sprites nor "movie symbols" can be used; use "graphic symbols" instead</li>
 <li>Visible figures must never overlap
  <ul>
   <li>Figures that are intended to appear to touch must be exactly 1mm apart during the time when they should appear to touch.
     (Note: the code doesn't yet detect touching, but it will need this requirement to be followed if it is ever to do so.)
   </li>
   <li>Figures that must be composed of several shapes, such as walls with corners, must be perfectly adjacent to the other parts of
      the figure that they are connected to; that is, there must be neither any overlap nor any gap.
      (Note: the code doesn't yet detect adjacent shapes in order to assemble them into a larger single figure, but it will need this
      requirement if it is ever to do so.)
   </li>
  </ul>
 </li>
 <li>All figures must be visually distinguishable from each other based on a label or color. Labels and colors must not
     change across frames. Figure colors must be easily distinguished from the background color.
     (We make these requirements because the code has access to a unique identifier for each figure that people
     can't see, so to keep participants on a level field with the code, one must provide visual uniqueness. We require that
     these properties not change because the code ignores them, and if they changed then participants and the code would
     not be comparable in their reactions.)</li>
 <li><font color=red>SOON TO CHANGE:</font> Figures must all be circles of the same size, because while the SWFDescriber code can distinguish shape
     and size differences, there aren't yet any rules in the reasoning part that can take advantage of
     such distinctions.</li>
 <li><font color=red>NEW:</font> Any figures whose shape isn't in set {triangle,circle,oval,square,rectangle} will be filtered out
     by perceptibilityFilter.pro because we don't have a way of calculating their area, so we can't assess
     their salience. (Another reason is that we can't tell if they change shape, which if it happened,
     should count as a discontinuity and therefore require handling by a specialized rule.)</li>
 <li>Figures may not enter or leave the frame, because the code has no knowledge yet of how to interpret such actions.</li>
 <li>The file format must use SWF version 8, because we use a 3rd party library to parse the file and the library has not
     been updated for more recent versions.</li>
</ul>

<h2><a name="logging">Logging</a></h2>
Logging functionality can be configured in Wayang.properties. The relevant setting parameters are:
<ul>
 <li>loggingMethod, with the following possible values: consoleOnly, logfileOnly, consoleAndLogfile.
 	 logfileOnly and consoleAndLogfile will print the log into a file named outputLog.csv. This file is placed in the Wayang home directory.</li>
 <li>loggingLevel, with the following possible values: completedEdges, allEdges, performanceData.
 	 completedEdges prints just the completed edges. allEdges prints both incomplete and completed edges. 
 	 performanceData prints relevant performance data with self-explanatory headings.
</ul>

<h2><a name="troubleshooting">Troubleshooting</a></h2>
<ul>
 <li>EclipseCLP doesn't support stepwise debugging in EclipseIDE, so we have to
use Start | Programs | Eclipse6.0 | TkEclipse instead.</li>
 <li>TkEclipse won't run the Java portions of our code, so we have to use
 mocked-up inputs. In TkEclipse, select File | Compile... and then select 
 Wayang\test\ECLiPSe\standalone_circleTranslation.pro; this will load all the
 ATOM and Wayang code, and then it defines mocked-up inputs as if they had been
 parsed from input\circle15mm_translation.swf</li>
 <li>To make console logging sufficiently verbose in TkEclipse, enter 
 "assert(traceParser)" (no quotes) into the top edit box of TkEclipse to turn on
 logging in IncrementalParser.ecl. You probably also want to enter 
 "assert(traceReasoner)" to turn on logging in ATOM (used by IncrementalParser).
 </li>
 <li>Entering "circleTranslation_edgesAreCorrect" in the textbox and hitting
 the "run" button would be a quick way to see all
 the console logging for a run over the mocked input.</li>
 <li>NOTE: If you need to do a second run, you need to restart TkEclipse and
 repeat these steps. DavidP hasn't figured out yet why this is so; it might be
 that one would have to retract very selectively, but he has forgotten.</li>
 <li>To do stepwise debugging, do all the steps above except don't hit "run".
 Instead, select Tools | Predicate Browser and scroll down to verifyRule/5 on
 the left; highlight it, then click the "on" radio button on the right next to
 "spy", then click Close. Now select Tools | Tracer and click the fullscreen
 button in the upper right. Finally, go back to the main window and enter 
 "circleTranslation_edgesAreCorrect" in the textbox and click Run. The Tracer
 window will reappear, and you can press Leap to go to the first call to 
 verifyRule/5, or press Creep to visit the first executable line of this run. If
 you pressed Leap, then press Creep to see the source code in the lower pane,
 and keep pressing Creep to step depth-first through the code (or Skip to avoid
 going any deeper but advance to the next line in the current method (if any)).
 </li>
</ul>

<h2><a name="notes">Notes</a></h2>
<ul>
<li>Without special effort to avoid it, new rules will tend to produce several edges that have the same start and end times and very similar LHSs. 
We call these &quot;duplicates&quot;. They are not needed for modeling inference, and they bog down the system both in processing time and RAM use. 
Edwin has tailored some of the existing rules so that their LHS indicates whether they were produced by a &quot;base&quot;-case or &quot;recursive&quot;-case rule, 
so that the RHS conditions of other rules can require or reject matches to LHSs produced by one case or the other. This update to rule format allows us to prevent 
most ways of producing duplicates that we know of so far, with the exception of wiggle rules, for which this mechanism is not suitable and there are other duplicate 
reduction mechanisms for wiggle rules. However, if we eventually allow frames to be spaced irregularly in time (to mimic retinal samplings), 
neither the original rule format nor this tweak would prevent a new way of producing duplicates: For samples close in time to each other, base rules might produce 
two edges starting at the same timepoint and ending at different timepoints, one covering T1 to T2 and the other covering T1 to T3, where T2 \= T3.
Edwin says that such duplicates would be prevented during regularly-spaced sequences because the perceptual filtering constraint requiring that there be no flicker 
would only be satisfied for one of the duplicate edges, i.e. the one that covers a shorter time period. [David: If the no-flicker constraint is what's keeping such 
duplicates from happening in regularly-spaced sequences, then we have a bug because that constraint is not meant to have that effect. There is an implicit constraint 
in many rules that there be no intervening frames among the frames explicitly mentioned in the RHS of the rule. We should probably make this adjacency constraint 
explicit in contingency conditions.]

Edwin says a possible way to handle the fact that the no-flicker constraint no longer prevents duplicates is to supplement the constraint on maximum time gap with another 
constraint in trajectory base rules that constrains the frame numbers of the frames being matched such that they are sequential. 
[David: One might also do it by creating a &quot;not&quot; constraint that looks for frames with a timestamp between the two given timestamps.]
</li>
</ul>

END
</body>
</html>