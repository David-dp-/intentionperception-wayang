:- lib(ic).
:- compile('KnowledgeBase_trajectory.ecl').

%DOC - Movement due to a goal to be at a certain position.
%There are 5 types of rules catering to 5 scenarios matching an intention to be at a position.
%Each type of rule has a corresponding type constant, which is stored in the last parameter in the LHS.
%The type constant is used to identify the type of rule used to generate an intendToBeAtposition edge.
%The types of rules and the corresponding type constants are: 
%1) A rule matching a single linear trajectory effect (type constant: base_linear)
%2) A rule matching a single stationary trajectory effect (type constant: base_stationary)
%3) A rule  matching two effects: (a) an intention to be at a position with base_linear or recursive_linear_linear as its type 
% constant followed by (b) a linear trajectory (type constant: recursive_linear_linear)
%4) A rule matching two effects: (a) an intention to be at a position with base_linear, recursive_linear_linear or
% recursive_linear_stationary as its type constant followed by (b) a stationary trajectory (type constant:
% recursive_linear_stationary)
%5) a rule matching two effects: (a) an intention to be at a position with base_stationary or recursive stationary_stationary as
% its type followed by (b) a stationary trajectory (type constant: recursive_stationary_stationary)
%Note that the first 2 rule types 1 and 2 (the base rules) have been combined into 1 implemented as a single rule. 
%

%Base case. This rule corresponds to rules 1 & 5 in the manuscript. 		
:- addRule(
	intendToBeAtPosition_baseStep,
	<=( cause(	intend( FigureId, 
						atPosition(FigureId,position(X2,Y2),
								   ElapsedTime2
								  ),
						Trajectory1,
						ElapsedTime1, ElapsedTime2,
						CF3,
						DrawInstrs,
					    BaseOrRecursive
					  ),
				[figureHasTrajectory(	FigureId,
										Trajectory1,
										ElapsedTime1,ElapsedTime2,
										CF1,
										originally(Shape1,Color1),
										_DrawInstrs1,
										BaseRecursiveOrWiggle
									)
				]
			 ),
		[1:compute((
					(%Either the agent moves to the intended position
					 Trajectory1 = linearMovingTrajectory(
									lastPosition(X2,Y2),
									magnitude(XMagn,YMagn),
									acceleration(AccelTriplets),_),
					 BaseOrRecursive = base_linear
					 %Check that the acceleration profile is consistent
					 %//TODO Constraint is very strict and the irregularities in animations we use could cause this constraint
		 			 %       to fail to be fulfilled. Comment out for now.
					 /*figureMovesWithConsistentAccelerationProfile(intendAtPositionOrAvoidApproach,
						AccelTriplets)*/
					 %Ensure speed doesn't exceed maximum speed
					 %Speed is sqrt(XMagn^2 + YMagn^2),
					 %hasMaxAbility(agent,speed,MaxSpeed),
					 %Speed =< MaxSpeed
					) 
					;
					%or stays in the position if it's been there all along
					Trajectory1 = stationaryTrajectory(
									originalPosition(X2,Y2)),
					BaseOrRecursive = base_stationary
				   )					
				  ),
		 %Constraint 2 ensures that the trajectory isn't generated by the trajectory recursive rule. The reason for this is that we 
		 %don't want longer trajectories to trigger the intention base rule, since longer spans should be handled by the intention 
		 %recursive rule. Without this constraint there would be duplicate ascriptions.
		 2:compute( BaseRecursiveOrWiggle \= recursive
		 		  ),
		 %We check for a potential collision in the future. 
		 %Agent's omniscience is assumed.
		 %There should be no objects on an intercept course with the agent.
		 3:compute( findall( FigureId2, 
		 		  			(
		 		  			 findAnyCorroboratingEdge(
		 		  				_SpanEnd1,_SpanEnd2,
		 		  				figureHasTrajectory(FigureId2,
		 											Trajectory2,
		 											ElapsedTime1b,
		 											ElapsedTime2,
		 											CF2,
		 											originally(Shape2,_Color2),
		 											_DrawInstrs2,
		 											_BaseRecursiveOrWiggle2),
		 						_CF2, _ParentId, _RHS_parsedParts ),
		 					 FigureId2 \= FigureId,
		 					 onInterceptCourse(Shape1,Trajectory1,
		 					 					Shape2,Trajectory2)
		 					),
		 					[] 
		 		  		   )
		 		  ),
		 %Check whether the moving object wiggles from ElapsedTime1 to ElapsedTime2
		 %Wiggling is an added sign of animacy and should increase the confidence 
		 %for the intention ascription.
		 4:compute((BaseRecursiveorWiggle = wiggle ->
		 				true %//TODO The only reason this contingency condition is present 
		 					 %  is to allow increasing the CF value for the wiggle case.
		 		   ;
		 		   		true
		 		  )),
		 5:compute(CF3 = CF1),
		 %Since we allow trajectories inferred from wiggles, this rule can cover more than 2 frames, so we guard against duplicates
		 %that can be generated either by a duplicate trajectory generated by a duplicate wiggle, or by the recursive_linear_linear rule.
		 %Check whether there's already an existing edge covering the same time period for the same figure, either with a higher CF value,
		 %of the recursive type, or both (Edges that have higher CFs and/or are generated recursively should take priority.) 
 	 	 %The constraint is satisfied if and only if there's no such edge.
 	 	 6:compute((findall(CF6,
 	 	 				    (findAnyCorroboratingEdge(_SpanEnd5,_SpanEnd6,
 	 	 				    						  intend(FigureId, 
															 atPosition(FigureId,position(X2,Y2),
								   							 			ElapsedTime2
								  									   ),
								  							 _SomeTrajectory,
															 ElapsedTime1, ElapsedTime2,
															 CF6,
															 _DrawInstrs3,
															 BaseOrRecursive2
															),
													  _CF7,_ParentId3,_RHS_parsedParts3
													 ),
							 (
		 					  %We don't want to compare bounded reals, float/2 will convert the CFs to float values if the
 	 				  		  %CFs are indeed bounded reals.
 	 				  		  FloatCF6 is float(CF6),
 	 				  		  FloatCF3 is float(CF3),
 	 				  		  FloatCF6 > FloatCF3
 	 				  		 ;
 	 				  		  BaseOrRecursive2 = recursive_linear_linear
 	 				  		 )
 	 				  		),
 	 				  		[]
 	 				  	   )
 	 			  )),
 	 	 %Generate draw instrs
 	 	 7:compute((RuleLHSWithoutDIWithCFReplaced = intend( FigureId, 
															 atPosition(FigureId,position(X2,Y2),
								   							 			ElapsedTime2
								  									   ),
															 ElapsedTime1, ElapsedTime2,
															 cv),
					generatePositionList(FigureId,ElapsedTime1,ElapsedTime2,PositionListForDI),
					genDrawInstructions(FigureId,Shape1,Color1,ElapsedTime1,ElapsedTime2,
			  		 					RuleLHSWithoutDIWithCFReplaced,CF3,[PositionListForDI],
			  		 					[X2,Y2],
			  		 					intentionToBeAtPosition,DrawInstrs)
 	 	 		  ))
		])).

%Recursive case. This rule corresponds to rule 3 in the manuscript.
%There are 3 variants, each handled by a separate rule.
%Intention to be at a position, achieved through two linear movements.
:- addRule(
	intendToBeAtPosition_recursiveStep_linear_linear,
	<=( cause(	intend(FigureId,
					   atPosition(FigureId,position(X3,Y3),
					   			  ElapsedTime3
					   			 ),
					   Trajectory2,
					   ElapsedTime1, ElapsedTime3,
					   CF4,
					   DrawInstrs,
					   recursive_linear_linear
					  ),
				[intend(FigureId,
						atPosition(FigureId,position(X2,Y2),
								   ElapsedTime2
								  ),
						Trajectory1,
						ElapsedTime1, ElapsedTime2,
						CF1,
						_DrawInstrs1,
						BaseOrRecursive
					   ),
				 figureHasTrajectory(FigureId,
				 					 Trajectory2,
				 					 ElapsedTime2, ElapsedTime3,
				 					 CF2,originally(Shape2,Color2),
				 					 _DrawInstrs2,
				 					 BaseRecursiveOrWiggle
				 					)				 
				]
			),
		[%atPosition(FigureId,(X1,Y1),ElapsedTime1)
		 1:compute(( LHS = 
					 [timestamp(ElapsedTime1),
					  figure(FigureId,position(X1,Y1),Shape1,Color1)],		
					 findAnyCorroboratingEdgeWithCut(_SpanEnd1,_SpanEnd2,LHS,_CF5,
											 _ParentId,_RHS_ParsedParts)
				   )
				  ),
		 %atPosition(FigureId,(X2,Y2),ElapsedTime2)
		 2:compute(( LHS2 =
		 			 [timestamp(ElapsedTime2),
		 			  figure(FigureId,position(X2,Y2),Shape2,Color2)],
		 			 findAnyCorroboratingEdgeWithCut(_SpanEnd3,_SpanEnd4,LHS2,_CF6,
		 									 _ParentId2,_RHS_ParsedParts2)
		 		   )	
		 		  ),
		 %Constraint 3 ensures that trajectory2 isn't generated by the trajectory recursive rule. The reason for this is that we don't want
		 %longer trajectories to trigger the intention recursive rule, since there should already be an intention edge with a longer
		 %intention component and shorter (i.e. base-rule generated ) trajectory component covering the same span from ElapsedTime1
		 %to ElapsedTime3. Without this constraint there would be duplicate ascriptions.
		 3:compute(delayableDisjunctedCalls([BaseRecursiveOrWiggle],BaseRecursiveOrWiggle \= recursive)
		 		  ),
		 4:compute((
		 			Trajectory1 = linearMovingTrajectory(
		 								lastPosition(X2,Y2),
		 								magnitude(XMagn1,YMagn1),
		 								acceleration(AccelerationTriplets1),_),
		 			Trajectory2 =
		 				linearMovingTrajectory(
		 					lastPosition(X3,Y3),
		 					magnitude(XMagn2,YMagn2),
		 					acceleration(AccelerationTriplets2),_),
		 			/*magnitudesAreWithinErrorRange(XMagn1,XMagn2),
					magnitudesAreWithinErrorRange(YMagn1,YMagn2),
		 			collinearOrdered( (X1,Y1),(X2,Y2),(X3,Y3) ),*/
		 			angleBetweenTwoVectorsIsCloseToZero(XMagn1,YMagn1,XMagn2,YMagn2),
		 			 %//TODO Constraint is very strict and the irregularities in animations we use could cause this constraint
		 			 %       to fail to be fulfilled. Comment out for now.
		 			/*Constraint1 = (append(AccelerationTriplets2,AccelerationTriplets1,CombinedAccelerationTriplets),
		 						   figureMovesWithConsistentAccelerationProfile(intendAtPositionOrAvoidApproach,
										CombinedAccelerationTriplets)
								  ),
		 			delayableDisjunctedCalls([AccelerationTriplets2],Constraint1),*/
					CF3 is 0.6 %CF3 value to be adjusted
				   )
				  ),  					
		 5:compute((Constraint2 = 
		             findall( FigureId2, 
		 		  			 (
		 		  			  findAnyCorroboratingEdge(
		 		  				 _SpanEnd7,_SpanEnd8,
		 		  				 figureHasTrajectory(FigureId2,
		 						  					 Trajectory3,
		 											 ElapsedTime2b,
		 											 ElapsedTime3,
		 											 _CF9,
		 											 originally(Shape4,_Color4),
		 											 _DrawInstrs4,
		 											 _BaseRecursiveOrWiggle3),
		 						 _CF10, _ParentId4, _RHS_parsedParts4 ),
		 					  FigureId2 \= FigureId,
		 					  onInterceptCourse(Shape2,Trajectory2,
		 					 					 Shape4,Trajectory3)
		 					 ),
		 					 [] 
		 		  		    ),
		 		    delayableDisjunctedCalls([ElapsedTime3],Constraint2)
		 		  )),
		 %Check whether the moving object wiggles from ElapsedTime2 to ElapsedTime3
		 %Wiggling is an added sign of animacy and should increase the confidence 
		 %for the intention ascription.
		 6:compute((Constraint5 = (BaseRecursiveOrWiggle = wiggle ->
		 							true %//TODO The only reason this contingency condition is present 
		 					 			 %  is to allow increasing the CF value for the wiggle case.
		 		   				  ;
		 		   					true
		 		   				  ),
		 		   	delayableDisjunctedCalls([BaseRecursiveOrWiggle],Constraint5)
		 		  )),
		 7:compute( combineConfidenceFactors([CF1,CF2,CF3],CF4) ),
		 %Constraint 3 only guards against duplicates caused by trajectories generated by the recursive trajectory rule.
		 %Allowing wiggles could generate more duplicates. We attempt to reduce those duplicates in the following constraints.
		 %Constraint 8 checks whether at least one of the following is true: 1)there exists a duplicate of the component  
		 %intention covering ElapsedTime1 to ElapsedTime2 with a higher CF value, where the component intention and the duplicate 
		 %are of the same type 2)the component intention is of the base_linear type, and there exists a duplicate of the recursive_linear_linear type.
		 %The constraint is satisfied if and only if a duplicate does not exist with either of the conditions satisified.
		 8:compute((Constraint3 = (findall(CF13,
		 								   (findAnyCorroboratingEdge(_SpanEnd11,_SpanEnd12,
		 															 intend(FigureId,
																			atPosition(FigureId,position(X2,Y2),
								   													   ElapsedTime2
								  										   			  ),
								  										   	_SomeTrajectory2,
																			ElapsedTime1, ElapsedTime2,
																			CF13,
																			_DrawInstrs6,
																			BaseOrRecursive2
																		   ),
																	 _CF14,_ParentId6,_RHS_parsedParts6
																	),
											(
											 %We don't want to compare bounded reals, float/2 will convert the CFs to float values if the
 	 				  						 %CFs are indeed bounded reals.
 	 				  						 FloatCF13 is float(CF13),
 	 				  						 FloatCF1 is float(CF1),
 	 				  						 FloatCF13 > FloatCF1,
 	 				  						 BaseOrRecursive = BaseOrRecursive2
 	 				  						;
 	 				  						 BaseOrRecursive = base_linear,
 	 				  						 BaseOrRecursive2 = recursive_linear_linear
 	 				  						)
 	 				  					   ),
 	 				  					   []
 	 				  					  )
 	 				  			  ),
 	 				%Delay if the second effect has not been matched, i.e. Trajectory2 is not yet bound.
 	 	 			%This will ensure all duplicates have already been generated.
 	 				delayableDisjunctedCalls([Trajectory2],Constraint3)
 	 			  )),
 	 	 %Constraint 9 checks whether there exists a duplicate of the high level intention covering ElapsedTime1 to ElapsedTime3 that satisfies 2 conditions:
 	 	 %1)it has a higher CF value. 2)it is of the recursive_linear_linear type. The constraint is satisfied if and only if there's no such duplicate. 
 	 	 %While constraint 8 guards against duplicates caused by duplicates of the intention component covering the same time period (ElapsedTime1 to ElapsedTime2),
 	 	 %constraint 9 guards against duplicates of the recursive_linear_linear type formed by an intention component covering a different time period (ElapsedTime1 to ElapsedTime2b, 
 	 	 %where ElapsedTime2b \= ElapsedTime2.) 
 	 	 9:compute((Constraint4 = (findall(CF15,
 	 	 								   (findAnyCorroboratingEdge(_SpanEnd13,_SpanEnd14,
 	 	 								   							 intend(FigureId,
					   														atPosition(FigureId,position(X3,Y3),
					   			  													   ElapsedTime3
					   			 													  ),
					   			 											_SomeTrajectory3,
					   												 		ElapsedTime1, ElapsedTime3,
					   												 		CF15,
					   												 		_DrawInstrs7,
					   												 		BaseOrRecursive3
					  													   ),
 	 	 								   							 _CF16,_ParentId7,_RHS_parsedParts7
 	 	 								   						    ),
 	 	 								   	%We don't want to compare bounded reals, float/2 will convert the CFs to float values if the
 	 				  						%CFs are indeed bounded reals.
 	 				  						FloatCF15 is float(CF15),
 	 				  						FloatCF4 is float(CF4),
 	 				  						FloatCF15 > FloatCF4,
 	 				  						BaseOrRecursive3 = recursive_linear_linear
 	 				  					   ),
 	 				  					   []
 	 				  					  )
 	 				  			  ),
 	 				delayableDisjunctedCalls([CF4],Constraint4) 	
 	 	 		  )),
 	 	 %Generate draw instrs
 	 	 10:compute((RuleLHSWithoutDIWithCFReplaced = intend( FigureId, 
															 atPosition(FigureId,position(X3,Y3),
								   							 			ElapsedTime3
								  									   ),
															 ElapsedTime1, ElapsedTime3,
															 cv),
					 generatePositionList(FigureId,ElapsedTime1,ElapsedTime3,PositionListForDI),
					 genDrawInstructions(FigureId,Shape1,Color1,ElapsedTime1,ElapsedTime3,
			  		 					RuleLHSWithoutDIWithCFReplaced,CF4,[PositionListForDI],
			  		 					[X3,Y3],
			  		 					intentionToBeAtPosition,DrawInstrs)
 	 	 		   ))  
		])).

%Intention to be at a position, achieved through a linear movement followed by a stationary one.		
:- addRule(
	intendToBeAtPosition_recursiveStep_linear_stationary,
	<=( cause(	intend(FigureId,
					   atPosition(FigureId,position(X2,Y2),
					   			  ElapsedTime3
					   			 ),
					   Trajectory2,
					   ElapsedTime1, ElapsedTime3,
					   CF4,
					   DrawInstrs,
					   recursive_linear_stationary
					  ),
				[intend(FigureId,
						atPosition(FigureId,position(X2,Y2),
								   ElapsedTime2
								  ),
						Trajectory1,
						ElapsedTime1, ElapsedTime2,
						CF1,
						_DrawInstrs1,
						BaseOrRecursive
					   ),
				 figureHasTrajectory(FigureId,
				 					 Trajectory2,
				 					 ElapsedTime2, ElapsedTime3,
				 					 CF2,originally(Shape2,Color2),
				 					 _DrawInstrs2,
				 					 BaseRecursiveOrWiggle
				 					)				 
				]
			),
		[%atPosition(FigureId,(X1,Y1),ElapsedTime1)
		 1:compute(( LHS = 
					 [timestamp(ElapsedTime1),
					  figure(FigureId,position(X1,Y1),Shape1,Color1)],		
					 findAnyCorroboratingEdgeWithCut(_SpanEnd1,_SpanEnd2,LHS,_CF5,
											 _ParentId,_RHS_ParsedParts)
				   )
				  ),
		 %atPosition(FigureId,(X2,Y2),ElapsedTime2)
		 2:compute(( LHS2 =
		 			 [timestamp(ElapsedTime2),
		 			  figure(FigureId,position(X2,Y2),Shape2,Color2)],
		 			 findAnyCorroboratingEdgeWithCut(_SpanEnd3,_SpanEnd4,LHS2,_CF6,
		 									 _ParentId2,_RHS_ParsedParts2)
		 		   )	
		 		  ),	  
		 3:compute((
		 			BaseOrRecursive \= recursive_stationary_stationary,
		 			BaseOrRecursive \= base_stationary,
		 			BaseRecursiveOrWiggle = base,
		 			Trajectory2 =
		 				stationaryTrajectory(
		 					originalPosition(X2,Y2)),
					CF3 is 0.6 %CF3 value to be adjusted
				   )
				  ),  					
		 4:compute((Constraint1 = 
		 			findall( FigureId2, 
		 		  			(
		 		  			 findAnyCorroboratingEdge(
		 		  				_SpanEnd7,_SpanEnd8,
		 		  				figureHasTrajectory(FigureId2,
		 											Trajectory3,
		 											ElapsedTime2b,
		 											ElapsedTime3,
		 											_CF9,
		 											originally(Shape4,_Color4),
		 											_DrawInstrs4,
		 											_BaseRecursiveOrWiggle3),
		 						_CF10, _ParentId4, _RHS_parsedParts4 ),
		 					 FigureId2 \= FigureId,	
		 					 onInterceptCourse(Shape2,Trajectory2,
		 					 					Shape4,Trajectory3)
		 					),
		 					[] 
		 		  		   ),
		 		    delayableDisjunctedCalls([ElapsedTime3],Constraint1)
		 		  )),
		 5:compute( combineConfidenceFactors([CF1,CF2,CF3],CF4) ),
		 %Constraint 6 checks whether at least one of the following is true: 1)there exists a duplicate of the component  
		 %intention covering ElapsedTime1 to ElapsedTime2 with a higher CF value, where the component intention and the duplicate 
		 %are of the same type 2)the component intention is of the base_linear type, and there exists a duplicate of the recursive_linear_linear type.
		 %The constraint is satisfied if and only if a duplicate does not exist with either of the conditions satisified.
		 6:compute((Constraint2 = (findall(CF11,
		 								   (findAnyCorroboratingEdge(_SpanEnd9,_SpanEnd10,
		 															 intend(FigureId,
																			atPosition(FigureId,position(X2,Y2),
								   													   ElapsedTime2
								  										   			  ),
								  										   	_SomeTrajectory,
																			ElapsedTime1, ElapsedTime2,
																			CF11,
																			_DrawInstrs5,
																			BaseOrRecursive2
																		   ),
																	 _CF12,_ParentId5,_RHS_parsedParts5
																	),
											(
											 %We don't want to compare bounded reals, float/2 will convert the CFs to float values if the
 	 				  						 %CFs are indeed bounded reals.
 	 				  						 FloatCF11 is float(CF11),
 	 				  						 FloatCF1 is float(CF1),
 	 				  						 FloatCF11 > FloatCF1,
 	 				  						 BaseOrRecursive = BaseOrRecursive2
 	 				  						;
 	 				  						 BaseOrRecursive = base_linear,
 	 				  						 BaseOrRecursive2 = recursive_linear_linear
 	 				  						)
 	 				  					   ),
 	 				  					   []
 	 				  					  )
 	 				  			  ),
 	 				%Delay if the second effect has not been matched, i.e. Trajectory2 is not yet bound.
 	 	 			%This will ensure all duplicates have already been generated.
 	 				delayableDisjunctedCalls([Trajectory2],Constraint2)
 	 			  )),
 	 	 %Generate draw instrs
 	 	 7:compute((RuleLHSWithoutDIWithCFReplaced = intend( FigureId, 
															 atPosition(FigureId,position(X2,Y2),
								   							 			ElapsedTime3
								  									   ),
															 ElapsedTime1, ElapsedTime3,
															 cv),
					generatePositionList(FigureId,ElapsedTime1,ElapsedTime3,PositionListForDI),
					genDrawInstructions(FigureId,Shape1,Color1,ElapsedTime1,ElapsedTime3,
			  		 					RuleLHSWithoutDIWithCFReplaced,CF4,[PositionListForDI],
			  		 					[X2,Y2],
			  		 					intentionToBeAtPosition,DrawInstrs)
 	 	 		  ))
		])).

%Intention to be at a position, achieved through two stationary movements.	
:- addRule(
	intendToBeAtPosition_recursiveStep_stationary_stationary,
	<=( cause(	intend(FigureId,
					   atPosition(FigureId,position(X2,Y2),
					   			  ElapsedTime3
					   			 ),
					   Trajectory2,
					   ElapsedTime1, ElapsedTime3,
					   CF4,
					   DrawInstrs,
					   recursive_stationary_stationary
					  ),
				[intend(FigureId,
						atPosition(FigureId,position(X2,Y2),
								   ElapsedTime2
								  ),
						Trajectory1,
						ElapsedTime1, ElapsedTime2,
						CF1,
						_DrawInstrs1,
						BaseOrRecursive
					   ),
				 figureHasTrajectory(FigureId,
				 					 Trajectory2,
				 					 ElapsedTime2, ElapsedTime3,
				 					 CF2,originally(Shape2,Color2),
				 					 _DrawInstrs2,BaseRecursiveOrWiggle
				 					)				 
				]
			),
		[%atPosition(FigureId,(X1,Y1),ElapsedTime1)
		 1:compute(( LHS = 
					 [timestamp(ElapsedTime1),
					  figure(FigureId,position(X1,Y1),Shape1,Color1)],		
					 findAnyCorroboratingEdgeWithCut(_SpanEnd1,_SpanEnd2,LHS,_CF5,
											 _ParentId,_RHS_ParsedParts)
				   )
				  ),
		 %atPosition(FigureId,(X2,Y2),ElapsedTime2)
		 2:compute(( LHS2 =
		 			 [timestamp(ElapsedTime2),
		 			  figure(FigureId,position(X2,Y2),Shape2,Color2)],
		 			 findAnyCorroboratingEdgeWithCut(_SpanEnd3,_SpanEnd4,LHS2,_CF6,
		 									 _ParentId2,_RHS_ParsedParts2)
		 		   )	
		 		  ),
		 %Constraint 3 ensures that trajectory2 isn't generated by the trajectory recursive rule. The reason for this is that we don't want
		 %longer trajectories to trigger the intention recursive rule, since there should already be an intention edge with a longer
		 %intention component and shorter (i.e. base-rule generated ) trajectory component covering the same span from ElapsedTime1
		 %to ElapsedTime3. Without this constraint there would be duplicate ascriptions.
		 3:compute(delayableDisjunctedCalls([BaseRecursiveOrWiggle],BaseRecursiveOrWiggle \= recursive)
		 		  ),
		 4:compute(((BaseOrRecursive = base_stationary
		 		    ;
		 		     BaseOrRecursive = recursive_stationary_stationary
		 		    ),
		 			Trajectory2 =
		 				stationaryTrajectory(
		 					originalPosition(X2,Y2)),
					CF3 is 0.5 %CF3 value to be adjusted
				   )
				  ),  					
		 5:compute((Constraint1 =
		 			findall( FigureId2, 
		 		  			(
		 		  			 findAnyCorroboratingEdge(
		 		  				_SpanEnd7,_SpanEnd8,
		 		  				figureHasTrajectory(FigureId2,
		 											Trajectory3,
		 											ElapsedTime2b,
		 											ElapsedTime3,
		 											_CF9,
		 											originally(Shape4,_Color4),
		 											_DrawInstr4, _BaseRecursiveOrWiggle3),
		 						_CF10, _ParentId4, _RHS_parsedParts4 ),
		 					 FigureId2 \= FigureId,
		 					 onInterceptCourse(Shape2,Trajectory2,
		 					 					Shape4,Trajectory3)
		 					),
		 					[] 
		 		  		   ),
		 		  	delayableDisjunctedCalls([ElapsedTime3],Constraint1)
		 		  )),
		 6:compute( combineConfidenceFactors([CF1,CF2,CF3],CF4) ),
		 %Generate draw instrs
		 7:compute((RuleLHSWithoutDIWithCFReplaced = intend( FigureId, 
															 atPosition(FigureId,position(X2,Y2),
								   							 			ElapsedTime3
								  									   ),
															 ElapsedTime1, ElapsedTime3,
															 cv),
					generatePositionList(FigureId,ElapsedTime1,ElapsedTime3,PositionListForDI),
					genDrawInstructions(FigureId,Shape1,Color1,ElapsedTime1,ElapsedTime3,
			  		 					RuleLHSWithoutDIWithCFReplaced,CF4,[PositionListForDI],
			  		 					[X2,Y2],
			  		 					intentionToBeAtPosition,DrawInstrs)
		 		  ))
		])).